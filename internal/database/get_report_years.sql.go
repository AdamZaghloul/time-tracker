// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: get_report_years.sql

package database

import (
	"context"
)

const getReportYears = `-- name: GetReportYears :many
DO $$ 
DECLARE 
    cols TEXT;
    query TEXT;
BEGIN
    -- Generate column names dynamically
    SELECT string_agg(DISTINCT quote_ident(EXTRACT(YEAR FROM a.start_time) AS "year"::text) || ' INT', ', ') 
    INTO cols
    FROM activities WHERE user_id = $1;

    -- Construct the crosstab query dynamically
    query := format(
        'SELECT * FROM crosstab(
            ''SELECT category_id, EXTRACT(YEAR FROM a.start_time) AS "year", SUM(ROUND(EXTRACT(EPOCH FROM (a.end_time - a.start_time))/60)) AS "duration" FROM activities WHERE user_id = $1 GROUP BY category_id, "year" ORDER BY category_id, "year"'',
            ''SELECT DISTINCT EXTRACT(YEAR FROM a.start_time) AS "year" FROM activities WHERE user_id = $1 ORDER BY "year"''
        ) AS ct (store TEXT, %s);', cols
    );

    -- Execute the query
    EXECUTE query;
END $$
`

type GetReportYearsRow struct {
}

func (q *Queries) GetReportYears(ctx context.Context) ([]GetReportYearsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReportYears)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportYearsRow
	for rows.Next() {
		var i GetReportYearsRow
		if err := rows.Scan(); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
